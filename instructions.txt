This project is called "TheFourthBook".

## Project Overview
THE FOURTH BOOK’s mission is to foster a sense of belonging, financial empowerment and unity among Africans in the Diaspora, enabling them to contribute meaningfully to the development of Africa while achieving financial security and stability. Through our innovative contributions and payout model, THE FOURTH BOOK aims to harness the strength of our community to make a significant impact, one member at a time; 

**IMPORTANT**: This is a MOBILE APP that promotes the platform and leads users to download the app. The web design provided is for reference, but we are building a mobile-first experience.

## Design System & Brand Identity

### Brand Colors
The Fourth Book uses a warm, culturally-rich color palette inspired by Pan-African heritage:

**Primary Color:**
- Deep Brown: `#571217` - Main brand color for headers, primary CTAs, and key UI elements

**Accent Colors:**
- Orange: `#F38218` - Primary accent for CTAs, highlights, and interactive elements
- Yellow: `#F8B735` - Secondary accent for warnings, highlights, and decorative elements
- Green: `#1A760D` - Success states, positive actions, and secondary brand color
- Deep Blue: `#040F40` - Info states, occasional accents, and trust elements

**Neutral Colors:**
- White: `#FFFFFF` - Light backgrounds, text on dark surfaces
- Black: `#000000` - Dark backgrounds (mobile menu), primary text
- Warm Cream/Beige: `#F5F1E8` - Alternative light background for warmth
- Gray tones: Various shades for text hierarchy and borders

### Color Usage Guidelines
- **Primary Brown**: Use for navigation headers, primary buttons, section headers
- **Orange**: Use for main CTAs ("Get Started", "Download App"), active states
- **Yellow**: Use for highlights, stats, important information
- **Green**: Use for success messages, verified badges, positive actions
- **Blue**: Use sparingly for informational elements, trust indicators
- **Cream Background**: Use for alternating sections to create visual rhythm

### Typography
**Font System** (from reference project):
- **Primary Headings**: Rhodium Regular (rhregular) - Bold, impactful
- **Body Text**: Nunito Medium (nunmedium) - Clean, readable
- **Emphasis**: Nunito Bold (nunbold) - Strong emphasis
- **Light Text**: Nunito Light (nunlight) - Subtle text
- **Alternative**: Metrophobic Regular (metroregular) - Special use cases

**Font Sizes:**
- Hero/Large Headings: 32-40px
- Section Headings: 24-28px
- Subheadings: 18-20px
- Body Text: 16px
- Small Text: 14px
- Caption: 12px

### Design Principles

1. **Cultural Authenticity**
   - Pan-African color scheme (red, yellow, green in logo)
   - Authentic photography of African diaspora
   - Community-focused visuals and messaging
   - World map imagery representing global reach

2. **Warmth & Approachability**
   - Warm color palette (brown, orange, cream)
   - Rounded corners on cards and images (12-16px radius)
   - Generous whitespace and padding
   - Friendly, authentic photography

3. **Impact & Power**
   - Bold typography for headlines
   - Strong color contrasts
   - Prominent CTAs with clear hierarchy
   - Emphasis on "power in numbers" messaging

4. **Professionalism**
   - Clean, modern layouts
   - Consistent spacing and alignment
   - Well-organized information hierarchy
   - Polished UI components

5. **Community Focus**
   - Emphasis on collective empowerment
   - Community photography and testimonials
   - Collaborative messaging
   - Inclusive design language

### Key UI Components (Mobile-First)

1. **Navigation**
   - Mobile: Full-screen overlay menu with black background
   - Logo at top with Pan-African colors (red, yellow, green books)
   - Vertical navigation with orange active state
   - World map background graphic
   - Decorative colored dots (Pan-African colors)
   - White "Contact Us" CTA button

2. **Hero Section**
   - Large, bold headline: "There Is Power, Real Power In Numbers!"
   - Compelling subtext explaining the mission
   - Primary CTA: Brown/Orange button ("Get Started")
   - Hero image: Authentic community member photography
   - Stats bar with key metrics (orange background)

3. **Cards & Content Blocks**
   - Rounded corners (12-16px)
   - Cream/white backgrounds
   - Orange icons for features/principles
   - Consistent padding (16-24px)
   - Clear typography hierarchy

4. **Forms**
   - Clean, minimal input fields
   - Orange focus states
   - Clear labels and placeholders
   - Brown submit buttons
   - Validation with green (success) and red (error)

5. **Image Grids**
   - Rounded corners on all images
   - Consistent gaps (12-16px)
   - Community-focused photography
   - 2-column grid on mobile

6. **CTAs & Buttons**
   - Primary: Deep brown background with white text
   - Secondary: Orange background with white text
   - Tertiary: Outlined with brown border
   - Rounded corners (8-12px)
   - Clear tap targets (minimum 44px height)

7. **Stats/Impact Display**
   - Orange background sections
   - White text for contrast
   - Bold numbers with descriptive labels
   - Vertical stacking on mobile

8. **App Download Section**
   - Phone mockup showing app interface
   - Feature list with checkmarks
   - App store badges (Apple + Google Play)
   - Cream background with decorative elements

### Spacing System
- **Extra Small**: 4px
- **Small**: 8px
- **Medium**: 16px
- **Large**: 24px
- **Extra Large**: 32px
- **Section Padding**: 40-60px vertical on mobile

### Animation & Interactions
- Smooth transitions (200-300ms)
- Subtle hover/press states on buttons
- Fade-in animations for content on scroll
- Number counters for statistics
- Smooth menu open/close transitions

### Accessibility
- Minimum contrast ratio: WCAG AA (4.5:1 for text)
- Touch targets: Minimum 44x44px
- Screen reader support with proper labels
- Keyboard navigation support
- Focus indicators on interactive elements

How we work:
Using these techniques below, we come up with methods to get to the fulfillment of our aims and visions:

Monthly Contributions - Members make regular contributions of $20USD, or its equivalent to the money of your residential country. or opt for semi-annual or annual contributions. These funds are the building blocks of our collective empowerment.
Monthly Payouts - At the end of each month, an impressive $1 million USD is distributed among five lucky members, selected solely through THE FOURTH BOOK’S specially designed APP, ensuring transparency and fairness

Our group's operation begins once our membership surpasses 50,000 members. Until this milestone is achieved, members are not required to make any payment as monthly, semi-annual or yearly contribution - this means we'll have to implement a system in this app where you see progress of how many members are in the app and only enable payments when that milestone is reached - of course the number can be edited any time.

## Reference Project
Learn coding patterns, structure, and conventions from:
`D:\KLASIQUE STUFF\D-klasique-projects\1mobile\cafatickets_fix\cafa-ticket-mobile`

## Tech Stack
- **Framework**: Expo SDK 54
- **Router**: Expo Router v6 (file-based routing)
- **Language**: TypeScript (strict mode)
- **Styling**: NativeWind v4 (Tailwind CSS for React Native)
- **State Management**: React Context API + hooks
- **Animations**: React Native Reanimated v3
- **State/Forms**: Formik + Yup for form validation
- **HTTP Client**: Axios with interceptors
- **UI Components**:
  - @gorhom/bottom-sheet
  - @shopify/flash-list (optimized lists)
  - expo-image
- **Navigation**: Expo Router with React Navigation
- **Storage**: 
  - expo-secure-store (tokens - encrypted)
  - AsyncStorage (user data/cache)

## Package Installation Guidelines (CRITICAL)

**ALWAYS check if a package exists before attempting to install it.**

### Before Installing Any Package:

1. **Check package.json first**:
   - Open `package.json` and search for the package name
   - Check both `dependencies` and `devDependencies`

2. **Verify in node_modules**:
   ```bash
   ls node_modules/package-name
   # or
   ls node_modules/@scope/package-name
   ```

3. **Common Pre-installed Packages**:
   - ✅ `react-native-reanimated` - Already installed
   - ✅ `expo-router` - Already installed
   - ✅ `nativewind` - Already installed
   - ✅ `@react-native-async-storage/async-storage` - Already installed
   - ✅ `@expo/vector-icons` - Already installed
   - ✅ `@shopify/flash-list` - Already installed
   - ✅ `@gorhom/bottom-sheet` - Already installed

4. **Installation Process** (only if package is NOT found):
   ```bash
   # For Expo-compatible packages (preferred)
   npx expo install package-name
   
   # For npm packages
   npm install package-name
   ```

**Never blindly run install commands without verification.**

## Documentation References
Backend API documentation located at:
1. "C:\Users\DELL\Documents\docs\lottery\Lottery_Authentication_UserManagement.docx"
2. "C:\Users\DELL\Documents\docs\lottery\Lottery_Dashboard_Notifications.docx"
3. "C:\Users\DELL\Documents\docs\lottery\Lottery_Draw_System.docx"
4. c:\Users\DELL\Documents\docs\lottery\Lottery_Payment_System.docx

## Project Structure (Following Reference Pattern)
```
app/                    # Expo Router file-based routes
  (auth)/              # Auth group (login, signup, onboarding)
  (tabs)/              # Tab navigation group (discover, matches, messages, profile)
  _layout.tsx          # Root layout with providers
  index.tsx            # Entry/splash screen
components/            # Reusable components
  ui/                  # UI components (AppButton, AppText, Screen, etc.)
  form/                # Form components (AppForm, AppFormField, etc.)
  layout/              # Layout components (TabBar, RequireAuth)
config/                # App configuration (colors, settings)
constants/             # Constants and icons
context/               # React contexts (AuthContext, UserContext, etc.)
hooks/                 # Custom hooks (useModal, useDebounce, etc.)
types/                 # TypeScript type definitions
utils/                 # Utility functions
data/                  # Mock data and validation schemas
lib/                   # API services and auth utilities
assets/                # Static assets (images, fonts)
```

## Naming Conventions

### Files
- **Components**: PascalCase (`ProfileCard.tsx`, `AppButton.tsx`)
- **Utilities**: camelCase (`validationUtils.ts`, `formatDate.ts`)
- **Types**: PascalCase with `.types.ts` suffix (`user.types.ts`, `dashboard.types.ts`)
- **Mock Data**: descriptive name with `.dummy.ts` suffix (`drawsData.dummy.ts`, `userData.dummy.ts`)
- **Validation Schemas**: descriptive with `Schema` suffix in `data/` folder (`validationSchema.ts`, `profileSchema.ts`)

### Components
- **UI components**: Prefixed with `App` (`AppButton`, `AppText`, `AppForm`, `AppInput`)
- **Feature components**: Descriptive names (eg: `ProfileCard`, `MatchCard`, `MessageBubble`)
- **Hooks**: Prefixed with `use` (`useModal`, `useDebounce`, `useAuth`, etc)
- **Contexts**: Suffixed with `Context` (`AuthContext`, `UserContext`)

### Variables
- **camelCase** for variables and functions
- **Boolean prefixes**: `is`, `has`, `can` (`isLoading`, `hasMatches`, `canMessage`)

### Imports
- **Organize imports** by separating third-party from local modules
- **Third-party first**: React, React Native, external libraries
- **Blank line separator**: Leave one blank line between third-party and local imports
- **Local imports**: Components, types, config, utils from `@/` paths
- **Example**:
```typescript
// Third-party imports
import React, { useState, useCallback } from 'react';
import { View, Text } from 'react-native';
import { FlashList } from '@shopify/flash-list';

// Local imports
import { AppButton, AppText } from '@/components/ui';
import { UserProfile } from '@/types/user.types';
import colors from '@/config/colors';
```

## Mock Data Pattern (Backend Not Ready)

Since the backend is not ready, simulate data based on documentation.

### Mock Images
- Use **Unsplash.com** for all mock profile photos and post images
- Format: `https://images.unsplash.com/photo-[id]?w=[width]&h=[height]&fit=crop`
- Use diverse, high-quality portraits for user profiles
- Use relevant lifestyle images for posts
- **NEVER** use local placeholder images (e.g., `require('@/assets/...')`) - use `blurhash` or Unsplash URLs instead

### Example 1: Get Current User Profile
**Documentation Data:**
```json
{
    "user_id": "usr_1234567890",
    "email": "user@example.com",
    "phone": "+1234567890",
    "first_name": "John",
    "last_name": "Doe",
    "country": "USA",
    "date_of_birth": "1990-01-15",
    "kyc_status": "verified",
    "kyc_verified_at": "2024-02-05T14:20:00Z",
    "email_verified": true,
    "phone_verified": true,
    "account_status": "active",
    "created_at": "2024-01-15T10:00:00Z",
    "updated_at": "2024-02-09T10:30:00Z",
    "referral_code": "JOHN1234",
    "referred_by": null
  }
```

**Implementation:**

1. **Create Type Definition** - `types/user.types.ts`:
```typescript
export interface CurrentUser {
  user_id: string;
  email: string;
  phone: string;
  first_name: string;
  last_name: string;
  country: string;
  date_of_birth: string; // ISO date string (e.g. "1990-01-15")
  kyc_status: "verified" | "pending" | "rejected" | string;
  kyc_verified_at: string | null; // ISO datetime string
  email_verified: boolean;
  phone_verified: boolean;
  account_status: "active" | "suspended" | "inactive" | string;
  created_at: string; // ISO datetime string
  updated_at: string; // ISO datetime string
  referral_code: string;
  referred_by: string | null;
}

```

2. **Create Mock Data** - `data/userData.dummy.ts`:
```typescript
import { CurrentUser } from "@/types/user.types";

export const currentUser: CurrentUser = {
    "user_id": "usr_1234567890",
    "email": "user@example.com",
    "phone": "+1234567890",
    "first_name": "John",
    "last_name": "Doe",
    "country": "USA",
    "date_of_birth": "1990-01-15",
    "kyc_status": "verified",
    "kyc_verified_at": "2024-02-05T14:20:00Z",
    "email_verified": true,
    "phone_verified": true,
    "account_status": "active",
    "created_at": "2024-01-15T10:00:00Z",
    "updated_at": "2024-02-09T10:30:00Z",
    "referral_code": "JOHN1234",
    "referred_by": null
  }
```

## Path Aliases
- `@/*` → project root (e.g., `@/components`, `@/context`, `@/types`)

## Dark Mode Compatibility (CRITICAL)

**ALL components and screens MUST be dark mode compatible.** The app uses a dynamic theme system that switches between light and dark modes based on user preference.

### Core Principle
**NEVER hardcode colors directly in components.** Always use the `useColors` hook to access theme-aware colors.

### Using the useColors Hook

**Location**: `config/colors.ts`

**Import and Usage**:
```typescript
import { useColors } from '@/config/colors';

const MyComponent = () => {
  const colors = useColors();
  
  return (
    <View style={{ backgroundColor: colors.background }}>
      <Text style={{ color: colors.textPrimary }}>Hello</Text>
    </View>
  );
};
```

## Performance Optimization (CRITICAL)

Performance is a TOP PRIORITY for this application. Users expect fast, responsive experiences.

### List Rendering Strategy

**CRITICAL RULE**: Choose the right list component based on data size and characteristics.

#### Use FlashList (@shopify/flash-list) for:
- **Large datasets** (>20 items)
- **Dynamic/growing lists** (pagination, infinite scroll)
- **Performance-critical lists** (smooth scrolling required)

**FlashList Use Cases**:
1. **Draw History** - Potentially hundreds of past draws
2. **Transaction History** - Hundreds of transactions over time
3. **Notifications List** - Growing chronological list
4. **Success Stories** - Growing testimonial list
5. **Your Participation History** - All months participated

**FlashList Best Practices**:
```typescript
import { FlashList } from '@shopify/flash-list';

<FlashList
  data={items}
  renderItem={({ item }) => <ItemComponent item={item} />}
  estimatedItemSize={100} // REQUIRED: Provide accurate estimate
  keyExtractor={(item) => item.id}
  onEndReached={loadMore} // Pagination
  onEndReachedThreshold={0.5}
  ListEmptyComponent={<EmptyState />}
  ListFooterComponent={isLoading ? <LoadingSpinner /> : null}
/>
```

#### Use FlatList for:
- **Medium datasets** (10-20 items)
- **Static lists** that don't grow
- **Lists with complex interactions** (drag-drop, swipe actions)

**FlatList Use Cases**:
1. **Payment Methods** - Typically 1-3 items
2. **Recent Activity** - Last 5-10 items
3. **Quick Actions** - 4-6 items

#### Use ScrollView for:
- **Small datasets** (<10 items)
- **Static content** (How It Works, Settings)
- **Mixed content** (not uniform list items)

**ScrollView Use Cases**:
1. **Profile Settings** - 10-15 items
2. **How It Works Steps** - 3-4 items
3. **Onboarding Slides** - 3-4 slides
4. **Dashboard Quick Actions** - 4-6 items

### Component Optimization

**1. Memoization**:
```typescript
// Memoize expensive components
const ExpensiveComponent = React.memo(({ data }) => {
  return <View>{/* render */}</View>;
});

// Memoize callbacks
const handlePress = useCallback(() => {
  // handle press
}, [dependencies]);

// Memoize computed values
const computedValue = useMemo(() => {
  return expensiveCalculation(data);
}, [data]);
```

**2. Image Optimization**:
- Use `expo-image` instead of React Native Image
- Always provide `blurhash` for placeholders
- Compress images (max 500KB for profiles)
- Use appropriate sizes (don't load 4K images for thumbnails)
- Lazy load images in lists

```typescript
import { Image } from 'expo-image';

<Image
  source={{ uri: imageUrl }}
  placeholder={{ blurhash: 'L6PZfSi_.AyE_3t7t7R**0o#DgR4' }}
  contentFit="cover"
  transition={200}
  style={styles.image}
/>
```

**3. API Optimization**:
- Implement pagination (20-50 items per page)
- Cache frequently accessed data (AsyncStorage)
- Debounce search inputs (300ms minimum)
- Use optimistic updates for better UX
- Implement pull-to-refresh

```typescript
// Debounce example
const debouncedSearch = useDebounce(searchQuery, 300);

useEffect(() => {
  if (debouncedSearch) {
    searchAPI(debouncedSearch);
  }
}, [debouncedSearch]);
```

**4. Navigation Optimization**:
- Lazy load tab screens
- Preload critical screens
- Minimize navigation params
- Use native stack for better performance

### Loading States

**ALWAYS provide loading states**:
- Skeleton screens for initial loads
- Shimmer effects for content loading
- Spinners for actions
- Progress indicators for uploads

```typescript
// Skeleton example
{isLoading ? (
  <SkeletonLoader />
) : (
  <ActualContent data={data} />
)}
```

---

## Accessibility Requirements (CRITICAL)

**ALL screens and components MUST meet WCAG AA standards.**

### 1. Screen Reader Support

**Every interactive element MUST have accessible labels**:
```typescript
<TouchableOpacity
  accessibilityLabel="Make payment for this month"
  accessibilityHint="Opens payment screen"
  accessibilityRole="button"
>
  <Text>Pay Now</Text>
</TouchableOpacity>
```

**Accessibility Properties**:
- `accessibilityLabel`: Describes what the element is
- `accessibilityHint`: Describes what happens when activated
- `accessibilityRole`: Defines the element type (button, link, header, etc.)
- `accessibilityState`: Current state (selected, disabled, checked)

**Heading Hierarchy**:
```typescript
<Text accessibilityRole="header" accessibilityLevel={1}>
  Main Heading
</Text>
<Text accessibilityRole="header" accessibilityLevel={2}>
  Subheading
</Text>
```

### 2. Touch Targets

**Minimum touch target size: 44x44px**

```typescript
// Bad
<TouchableOpacity style={{ width: 20, height: 20 }}>
  <Icon name="close" size={16} />
</TouchableOpacity>

// Good
<TouchableOpacity style={{ width: 44, height: 44, justifyContent: 'center', alignItems: 'center' }}>
  <Icon name="close" size={16} />
</TouchableOpacity>
```

### 3. Color Contrast

**WCAG AA Requirements**:
- Normal text (16px+): 4.5:1 contrast ratio
- Large text (24px+): 3:1 contrast ratio
- UI components: 3:1 contrast ratio

**Test in both light and dark modes**

**Never rely solely on color**:
```typescript
// Bad - only color indicates error
<TextInput style={{ borderColor: 'red' }} />

// Good - color + icon + text
<View>
  <TextInput style={{ borderColor: colors.error }} />
  <Icon name="error" color={colors.error} />
  <Text style={{ color: colors.error }}>Invalid email</Text>
</View>
```

### 4. Form Accessibility

```typescript
<View>
  <Text accessibilityRole="text" nativeID="emailLabel">
    Email Address
  </Text>
  <TextInput
    accessibilityLabel="Email address"
    accessibilityLabelledBy="emailLabel"
    accessibilityHint="Enter your email to sign in"
    autoComplete="email"
    keyboardType="email-address"
    textContentType="emailAddress"
  />
  {error && (
    <Text
      accessibilityRole="alert"
      accessibilityLive="polite"
      style={{ color: colors.error }}
    >
      {error}
    </Text>
  )}
</View>
```

### 5. Dynamic Type Support

**Support text scaling (up to 200%)**:
```typescript
// Use relative sizes, not fixed
<Text style={{ fontSize: 16, lineHeight: 24 }}>
  Body text
</Text>

// Avoid fixed heights for text containers
<View style={{ minHeight: 44, paddingVertical: 8 }}>
  <Text>Flexible text container</Text>
</View>
```

### 6. Reduced Motion

**Respect user's motion preferences**:
```typescript
import { AccessibilityInfo } from 'react-native';

const [reduceMotion, setReduceMotion] = useState(false);

useEffect(() => {
  AccessibilityInfo.isReduceMotionEnabled().then(setReduceMotion);
}, []);

// Use in animations
<Animated.View
  style={{
    transform: [{
      translateX: reduceMotion ? 0 : animatedValue
    }]
  }}
/>
```

---

## Best Programming Practices

### 1. TypeScript Strict Mode

**ALWAYS use TypeScript with strict mode enabled**:
- Define interfaces for all data structures
- No `any` types (use `unknown` if necessary)
- Proper type guards for runtime checks
- Generic types for reusable components

```typescript
// Good
interface User {
  id: string;
  name: string;
  email: string;
}

const UserCard: React.FC<{ user: User }> = ({ user }) => {
  return <View>{/* render */}</View>;
};

// Bad
const UserCard = ({ user }: any) => {
  return <View>{/* render */}</View>;
};
```

### 2. Error Handling

**ALWAYS handle errors gracefully**:

```typescript
// API calls
try {
  const response = await api.makePayment(amount);
  // Success handling
} catch (error) {
  if (error.response?.status === 401) {
    // Handle authentication error
    logout();
  } else if (error.response?.status === 400) {
    // Handle validation error
    showError(error.response.data.message);
  } else {
    // Handle network/unknown error
    showError('Something went wrong. Please try again.');
  }
  // Log error for debugging
  console.error('Payment error:', error);
}
```

**Error Boundaries**:
```typescript
// Wrap critical sections with error boundaries
<ErrorBoundary fallback={<ErrorScreen />}>
  <CriticalComponent />
</ErrorBoundary>
```

### 3. Form Validation

**Use Formik + Yup for all forms**:

```typescript
import { Formik } from 'formik';
import * as Yup from 'yup';

const validationSchema = Yup.object().shape({
  email: Yup.string()
    .email('Invalid email')
    .required('Email is required'),
  password: Yup.string()
    .min(8, 'Password must be at least 8 characters')
    .required('Password is required'),
});

<Formik
  initialValues={{ email: '', password: '' }}
  validationSchema={validationSchema}
  onSubmit={handleSubmit}
>
  {({ handleChange, handleBlur, handleSubmit, values, errors, touched }) => (
    <View>
      <AppFormField
        name="email"
        placeholder="Email"
        error={touched.email && errors.email}
      />
      <AppButton onPress={handleSubmit} title="Submit" />
    </View>
  )}
</Formik>
```

### 4. Code Organization

**Keep components small and focused**:
- Single Responsibility Principle
- Extract complex logic to custom hooks
- Separate business logic from UI
- Maximum 200 lines per component (guideline)

```typescript
// Good - separated concerns
const usePaymentLogic = () => {
  const [isLoading, setIsLoading] = useState(false);
  
  const makePayment = async (amount: number) => {
    setIsLoading(true);
    try {
      const result = await api.payment(amount);
      return result;
    } finally {
      setIsLoading(false);
    }
  };
  
  return { makePayment, isLoading };
};

const PaymentScreen = () => {
  const { makePayment, isLoading } = usePaymentLogic();
  
  return <View>{/* UI only */}</View>;
};
```

### 5. Testing Requirements

**Write tests for critical functionality**:

**Unit Tests** (utils, helpers, validation):
```typescript
// validationUtils.test.ts
import { validateEmail } from './validationUtils';

describe('validateEmail', () => {
  it('should return true for valid email', () => {
    expect(validateEmail('test@example.com')).toBe(true);
  });
  
  it('should return false for invalid email', () => {
    expect(validateEmail('invalid')).toBe(false);
  });
});
```

**Component Tests** (critical UI components):
```typescript
import { render, fireEvent } from '@testing-library/react-native';
import { AppButton } from './AppButton';

describe('AppButton', () => {
  it('should call onPress when pressed', () => {
    const onPress = jest.fn();
    const { getByText } = render(
      <AppButton title="Click me" onPress={onPress} />
    );
    
    fireEvent.press(getByText('Click me'));
    expect(onPress).toHaveBeenCalled();
  });
});
```

### 6. Security Best Practices

**Sensitive Data Storage**:
```typescript
import * as SecureStore from 'expo-secure-store';

// Store tokens securely
await SecureStore.setItemAsync('authToken', token);

// Retrieve tokens
const token = await SecureStore.getItemAsync('authToken');

// Delete tokens
await SecureStore.deleteItemAsync('authToken');
```

**Never log sensitive data**:
```typescript
// Bad
console.log('User password:', password);
console.log('Auth token:', token);

// Good
console.log('Login attempt for user:', email);
console.log('Auth token received:', token ? 'Yes' : 'No');
```

### 7. Code Quality Tools

**Use ESLint and Prettier**:
- Configure ESLint for TypeScript
- Use Prettier for consistent formatting
- Run linting before commits
- Fix all warnings (zero-warning policy)

### 8. Documentation

**Document complex logic**:
```typescript
/**
 * Calculates the user's eligibility for the monthly draw
 * 
 * @param userId - The user's unique identifier
 * @param paymentStatus - Current month's payment status
 * @returns true if user is eligible, false otherwise
 * 
 * Eligibility criteria:
 * - Payment for current month must be completed
 * - Account must be active
 * - KYC must be verified
 */
const checkDrawEligibility = (
  userId: string,
  paymentStatus: PaymentStatus
): boolean => {
  // Implementation
};
```

---

## State Management Guidelines

### Context Usage

**Create contexts for global state**:
```typescript
// AuthContext.tsx
interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
}

export const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};
```

**Avoid prop drilling**:
- Use Context for data needed in many components
- Keep local state for component-specific data
- Use custom hooks to encapsulate context logic

---

## API Integration Guidelines

### API Client Setup

**Use Axios with interceptors**:
```typescript
// lib/apiClient.ts
import axios from 'axios';
import * as SecureStore from 'expo-secure-store';

const apiClient = axios.create({
  baseURL: process.env.EXPO_PUBLIC_API_URL,
  timeout: 10000,
});

// Request interceptor - add auth token
apiClient.interceptors.request.use(async (config) => {
  const token = await SecureStore.getItemAsync('authToken');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Response interceptor - handle errors
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      // Token expired - logout
      await SecureStore.deleteItemAsync('authToken');
      // Navigate to login
    }
    return Promise.reject(error);
  }
);

export default apiClient;
```

### API Service Pattern

```typescript
// lib/services/paymentService.ts
import apiClient from '../apiClient';

export const paymentService = {
  makePayment: async (amount: number) => {
    const response = await apiClient.post('/payments', { amount });
    return response.data;
  },
  
  getTransactionHistory: async (page: number = 1, limit: number = 20) => {
    const response = await apiClient.get('/payments/history', {
      params: { page, limit }
    });
    return response.data;
  },
};
```

---

## Offline Support

**Handle offline scenarios gracefully**:

```typescript
import NetInfo from '@react-native-community/netinfo';

const [isConnected, setIsConnected] = useState(true);

useEffect(() => {
  const unsubscribe = NetInfo.addEventListener(state => {
    setIsConnected(state.isConnected ?? false);
  });
  
  return () => unsubscribe();
}, []);

// Show offline banner
{!isConnected && (
  <View style={styles.offlineBanner}>
    <Text>No internet connection</Text>
  </View>
)}
```

---

## Performance Monitoring

**Track key metrics**:
- App startup time
- Screen transition time
- API response times
- Crash reports
- User analytics

**Use React Native Performance**:
```typescript
import { PerformanceObserver, performance } from 'react-native-performance';

// Mark important events
performance.mark('screen-loaded');

// Measure duration
performance.measure('screen-load-time', 'navigationStart', 'screen-loaded');
```

---

These guidelines ensure the app is performant, accessible, secure, and maintainable. Follow them strictly for all development work.