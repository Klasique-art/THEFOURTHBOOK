This project is called "TheFourthBook".

## Project Overview
THE FOURTH BOOKâ€™s mission is to foster a sense of belonging, financial empowerment and unity among Africans in the Diaspora, enabling them to contribute meaningfully to the development of Africa while achieving financial security and stability. Through our innovative contributions and payout model, THE FOURTH BOOK aims to harness the strength of our community to make a significant impact, one member at a time; 

**IMPORTANT**: This is a MOBILE APP that promotes the platform and leads users to download the app. The web design provided is for reference, but we are building a mobile-first experience.

## Design System & Brand Identity

### Brand Colors
The Fourth Book uses a warm, culturally-rich color palette inspired by Pan-African heritage:

**Primary Color:**
- Deep Brown: `#571217` - Main brand color for headers, primary CTAs, and key UI elements

**Accent Colors:**
- Orange: `#F38218` - Primary accent for CTAs, highlights, and interactive elements
- Yellow: `#F8B735` - Secondary accent for warnings, highlights, and decorative elements
- Green: `#1A760D` - Success states, positive actions, and secondary brand color
- Deep Blue: `#040F40` - Info states, occasional accents, and trust elements

**Neutral Colors:**
- White: `#FFFFFF` - Light backgrounds, text on dark surfaces
- Black: `#000000` - Dark backgrounds (mobile menu), primary text
- Warm Cream/Beige: `#F5F1E8` - Alternative light background for warmth
- Gray tones: Various shades for text hierarchy and borders

### Color Usage Guidelines
- **Primary Brown**: Use for navigation headers, primary buttons, section headers
- **Orange**: Use for main CTAs ("Get Started", "Download App"), active states
- **Yellow**: Use for highlights, stats, important information
- **Green**: Use for success messages, verified badges, positive actions
- **Blue**: Use sparingly for informational elements, trust indicators
- **Cream Background**: Use for alternating sections to create visual rhythm

### Typography
**Font System** (from reference project):
- **Primary Headings**: Rhodium Regular (rhregular) - Bold, impactful
- **Body Text**: Nunito Medium (nunmedium) - Clean, readable
- **Emphasis**: Nunito Bold (nunbold) - Strong emphasis
- **Light Text**: Nunito Light (nunlight) - Subtle text
- **Alternative**: Metrophobic Regular (metroregular) - Special use cases

**Font Sizes:**
- Hero/Large Headings: 32-40px
- Section Headings: 24-28px
- Subheadings: 18-20px
- Body Text: 16px
- Small Text: 14px
- Caption: 12px

### Voice & Tone (CRITICAL)

**This is a COMMUNITY app. The app should speak TO members, not AT them.**

The Fourth Book is built by the community, for the community. Every piece of text should make members feel like they're part of something bigger - a movement, a family, a collective force for change.

**Core Principles:**

1. **We, Not You**
   - âœ… "Together, we're building something powerful"
   - âœ… "Our community is growing stronger every day"
   - âŒ "You can contribute to the pool"
   - âŒ "Your membership helps others"

2. **Empowering & Motivational**
   - âœ… "There Is Power, Real Power In Numbers!"
   - âœ… "We're almost there! Just 17,550 more members until we activate monthly payouts!"
   - âœ… "Together, we've already changed 15 lives. Who's next?"
   - âŒ "Membership target not reached"
   - âŒ "15 winners selected"

3. **Inclusive & Warm**
   - âœ… "Welcome back, family!"
   - âœ… "Your contribution strengthens our collective"
   - âœ… "Every member counts. You count."
   - âŒ "User dashboard"
   - âŒ "Account overview"

4. **Celebratory & Positive**
   - âœ… "ðŸŽ‰ Congratulations to our latest winners!"
   - âœ… "Amazing! Our community just hit 30,000 members!"
   - âœ… "Your next contribution brings us closer to our goal"
   - âŒ "Payment successful"
   - âŒ "Transaction completed"

5. **Transparent & Honest**
   - âœ… "We need 50,000 members before monthly payouts begin. Here's why..."
   - âœ… "Your contribution goes directly into our collective pool"
   - âœ… "Every draw is fair, transparent, and randomly selected"
   - âŒ "Terms and conditions apply"
   - âŒ "Subject to verification"

**Language Examples:**

**Greetings:**
- "Good morning, [Name]! Ready to make today count?"
- "Welcome back, family!"
- "Hello, [Name]! Our community is stronger with you here"

**Progress Messages:**
- "We're 64% there! Together, we can reach 50,000 members"
- "Your contribution this month strengthens our collective power"
- "Almost there! Just [X] more members until we activate payouts"

**Success Messages:**
- "ðŸŽ‰ Congratulations! You're now part of this month's draw"
- "Amazing! Your contribution is in. Together, we're unstoppable"
- "Yes! Our community just welcomed member #[X]"

**Empty States:**
- "Be the first to contribute this month and inspire others!"
- "No winners yet, but that could change with the next draw. Will it be you?"
- "Your journey with us starts here. Ready to take the first step?"

**Error Messages:**
- "Oops! Something didn't go as planned. Let's try that again together"
- "We couldn't process that right now. Our team is on it!"
- "Hold on! We need to verify a few details before we continue"

**Call-to-Actions:**
- "Join the Movement" (not "Sign Up")
- "Make Your Contribution" (not "Pay Now")
- "Invite Your Circle" (not "Refer Friends")
- "See Our Winners" (not "View Results")
- "Strengthen Our Collective" (not "Add Funds")

**Notifications:**
- "ðŸŽŠ Big news! The draw is happening in 24 hours!"
- "Your contribution window closes soon. Don't miss out!"
- "Someone in our community just won $200,000. Next month, it could be you!"

**Rules:**
1. **Always use "we", "our", "us"** when referring to the community
2. **Use "you" sparingly** - only when addressing individual actions
3. **Add emojis thoughtfully** - celebrate wins, mark milestones, show warmth
4. **Be conversational** - write like you're talking to a friend
5. **Show the impact** - "Together, we've distributed $3M" not "Total payouts: $3M"
6. **Inspire action** - every message should motivate or encourage
7. **Celebrate milestones** - acknowledge progress, big and small

## Design Principles

1. **Cultural Authenticity**
   - Pan-African color scheme (red, yellow, green in logo)
   - Authentic photography of African diaspora
   - Community-focused visuals and messaging
   - World map imagery representing global reach

2. **Warmth & Approachability**
   - Warm color palette (brown, orange, cream)
   - Rounded corners on cards and images (12-16px radius)
   - Generous whitespace and padding
   - Friendly, authentic photography

3. **Impact & Power**
   - Bold typography for headlines
   - Strong color contrasts
   - Prominent CTAs with clear hierarchy
   - Emphasis on "power in numbers" messaging

4. **Professionalism**
   - Clean, modern layouts
   - Consistent spacing and alignment
   - Well-organized information hierarchy
   - Polished UI components

5. **Community Focus**
   - Emphasis on collective empowerment
   - Community photography and testimonials
   - Collaborative messaging
   - Inclusive design language

### Key UI Components (Mobile-First)

1. **Navigation**
   - Mobile: Full-screen overlay menu with black background
   - Logo at top with Pan-African colors (red, yellow, green books)
   - Vertical navigation with orange active state
   - World map background graphic
   - Decorative colored dots (Pan-African colors)
   - White "Contact Us" CTA button

2. **Hero Section**
   - Large, bold headline: "There Is Power, Real Power In Numbers!"
   - Compelling subtext explaining the mission
   - Primary CTA: Brown/Orange button ("Get Started")
   - Hero image: Authentic community member photography
   - Stats bar with key metrics (orange background)

3. **Cards & Content Blocks**
   - Rounded corners (12-16px)
   - Cream/white backgrounds
   - Orange icons for features/principles
   - Consistent padding (16-24px)
   - Clear typography hierarchy

4. **Forms**
   - Clean, minimal input fields
   - Orange focus states
   - Clear labels and placeholders
   - Brown submit buttons
   - Validation with green (success) and red (error)

5. **Image Grids**
   - Rounded corners on all images
   - Consistent gaps (12-16px)
   - Community-focused photography
   - 2-column grid on mobile

6. **CTAs & Buttons**
   - Primary: Deep brown background with white text
   - Secondary: Orange background with white text
   - Tertiary: Outlined with brown border
   - Rounded corners (8-12px)
   - Clear tap targets (minimum 44px height)

7. **Stats/Impact Display**
   - Orange background sections
   - White text for contrast
   - Bold numbers with descriptive labels
   - Vertical stacking on mobile

8. **App Download Section**
   - Phone mockup showing app interface
   - Feature list with checkmarks
   - App store badges (Apple + Google Play)
   - Cream background with decorative elements

### Spacing System
- **Extra Small**: 4px
- **Small**: 8px
- **Medium**: 16px
- **Large**: 24px
- **Extra Large**: 32px
- **Section Padding**: 40-60px vertical on mobile

### Animation & Interactions
- Smooth transitions (200-300ms)
- Subtle hover/press states on buttons
- Fade-in animations for content on scroll
- Number counters for statistics
- Smooth menu open/close transitions

### Accessibility
- Minimum contrast ratio: WCAG AA (4.5:1 for text)
- Touch targets: Minimum 44x44px
- Screen reader support with proper labels
- Keyboard navigation support
- Focus indicators on interactive elements

How we work:
Using these techniques below, we come up with methods to get to the fulfillment of our aims and visions:

Monthly Contributions - Members make regular contributions of $20USD, or its equivalent to the money of your residential country. or opt for semi-annual or annual contributions. These funds are the building blocks of our collective empowerment.
Monthly Payouts - At the end of each month, an impressive $1 million USD is distributed among five lucky members, selected solely through THE FOURTH BOOKâ€™S specially designed APP, ensuring transparency and fairness

Our group's operation begins once our membership surpasses 50,000 members. Until this milestone is achieved, members are not required to make any payment as monthly, semi-annual or yearly contribution - this means we'll have to implement a system in this app where you see progress of how many members are in the app and only enable payments when that milestone is reached - of course the number can be edited any time.

## Reference Project
Learn coding patterns, structure, and conventions from:
`D:\KLASIQUE STUFF\D-klasique-projects\1mobile\cafatickets_fix\cafa-ticket-mobile`

## Tech Stack
- **Framework**: Expo SDK 54
- **Router**: Expo Router v6 (file-based routing)
- **Language**: TypeScript (strict mode)
- **Styling**: NativeWind v4 (Tailwind CSS for React Native)
- **State Management**: React Context API + hooks
- **Animations**: React Native Reanimated v3
- **State/Forms**: Formik + Yup for form validation
- **HTTP Client**: Axios with interceptors
- **UI Components**:
  - @gorhom/bottom-sheet
  - @shopify/flash-list (optimized lists)
  - expo-image
- **Navigation**: Expo Router with React Navigation
- **Storage**: 
  - expo-secure-store (tokens - encrypted)
  - AsyncStorage (user data/cache)

## Package Installation Guidelines (CRITICAL)

**ALWAYS check if a package exists before attempting to install it.**

### Before Installing Any Package:

1. **Check package.json first**:
   - Open `package.json` and search for the package name
   - Check both `dependencies` and `devDependencies`

2. **Verify in node_modules**:
   ```bash
   ls node_modules/package-name
   # or
   ls node_modules/@scope/package-name
   ```

3. **Common Pre-installed Packages**:
   - âœ… `react-native-reanimated` - Already installed
   - âœ… `expo-router` - Already installed
   - âœ… `nativewind` - Already installed
   - âœ… `@react-native-async-storage/async-storage` - Already installed
   - âœ… `@expo/vector-icons` - Already installed
   - âœ… `@shopify/flash-list` - Already installed
   - âœ… `@gorhom/bottom-sheet` - Already installed

4. **Installation Process** (only if package is NOT found):
   ```bash
   # For Expo-compatible packages (preferred)
   npx expo install package-name
   
   # For npm packages
   npm install package-name
   ```

**Never blindly run install commands without verification.**

## Git Workflow Guidelines

### Pushing Changes to GitHub

**When the user says "push changes to github", automatically run all git commands without waiting for approval.**

**Standard workflow:**
```bash
# 1. Check status (safe to auto-run)
git status

# 2. Stage all changes (safe to auto-run)
git add .

# 3. Commit with descriptive message (REQUIRES USER APPROVAL)
git commit -m "feat: descriptive commit message"

# 4. Push to remote (REQUIRES USER APPROVAL)
git push
```

**Commit Message Format:**
- Use conventional commits: `feat:`, `fix:`, `docs:`, `style:`, `refactor:`, `test:`, `chore:`
- Be descriptive and concise
- Include what was changed and why
- Example: `feat: implement animated tab bar with dark mode support`

**Auto-run Rules:**
- `git status` - Always safe to auto-run
- `git add .` - Always safe to auto-run
- `git commit` - Requires user approval (SafeToAutoRun: false)
- `git push` - Requires user approval (SafeToAutoRun: false)

**When user says "push changes to github":**
1. Run `git status` (auto)
2. Run `git add .` (auto)
3. Run `git commit -m "..."` (wait for approval)
4. Run `git push` (wait for approval)

## Barrel Export Pattern (CRITICAL)

**ALWAYS use barrel exports (index.ts files) for cleaner imports.**

### What are Barrel Exports?

Barrel exports consolidate multiple exports from a directory into a single `index.ts` file, allowing cleaner imports.

### Implementation

**Create `index.ts` in each major directory:**

1. **components/index.ts**:
```typescript
// UI Components
export { default as AppBottomSheet } from './ui/AppBottomSheet';
export { default as AppButton } from './ui/AppButton';
export { default as AppSwitch } from './ui/AppSwitch';
export { default as AppText } from './ui/AppText';
export { default as ConfirmAction } from './ui/ConfirmAction';
export { default as Nav } from './ui/Nav';
export { default as Screen } from './ui/Screen';

// Layout Components
export { default as CustomTabBar } from './layout/CustomTabBar';

// Re-export types
export type { AppBottomSheetRef } from './ui/AppBottomSheet';
```

2. **context/index.ts**:
```typescript
// Theme Context
export { ThemeProvider, useTheme } from './ThemeContext';
export type { Theme } from './ThemeContext';

// Add other contexts as they're created
// export { AuthProvider, useAuth } from './AuthContext';
```

3. **config/index.ts**:
```typescript
// Color utilities
export { useColors, lightColors, darkColors } from './colors';
export type { Theme } from './colors';
```

4. **hooks/index.ts** (when created):
```typescript
// Custom hooks
export { default as useDebounce } from './useDebounce';
export { default as useModal } from './useModal';
// etc.
```

### Usage Examples

**Before (without barrel exports):**
```typescript
import AppButton from '@/components/ui/AppButton';
import AppText from '@/components/ui/AppText';
import Screen from '@/components/ui/Screen';
import { useTheme } from '@/context/ThemeContext';
import { useColors } from '@/config/colors';
```

**After (with barrel exports):**
```typescript
import { AppButton, AppText, Screen } from '@/components';
import { useTheme } from '@/context';
import { useColors } from '@/config';
```

### Rules

1. **Always create/update index.ts** when adding new components, hooks, or contexts
2. **Export both default exports and named exports** as appropriate
3. **Re-export types** that are needed by consumers
4. **Group exports logically** with comments (UI Components, Layout Components, etc.)
5. **Update barrel exports immediately** when creating new files

### When to Create Barrel Exports

- âœ… `components/` - For all UI and layout components
- âœ… `context/` - For all context providers and hooks
- âœ… `config/` - For configuration utilities
- âœ… `hooks/` - For custom hooks (when directory exists)
- âœ… `utils/` - For utility functions (when directory exists)
- âœ… `types/` - For TypeScript types (when directory exists)
- âŒ `app/` - Do NOT create barrel exports (Expo Router uses file-based routing)
- âŒ `lib/` - Usually not needed (API services imported individually)

## Documentation References
Backend API documentation located at:
1. "C:\Users\DELL\Documents\docs\lottery\Lottery_Authentication_UserManagement.docx"
2. "C:\Users\DELL\Documents\docs\lottery\Lottery_Dashboard_Notifications.docx"
3. "C:\Users\DELL\Documents\docs\lottery\Lottery_Draw_System.docx"
4. c:\Users\DELL\Documents\docs\lottery\Lottery_Payment_System.docx

## Project Structure (Following Reference Pattern)
```
app/                    # Expo Router file-based routes
  (auth)/              # Auth group (login, signup, onboarding)
  (tabs)/              # Tab navigation group (discover, matches, messages, profile)
  _layout.tsx          # Root layout with providers
  index.tsx            # Entry/splash screen
components/            # Reusable components
  ui/                  # UI components (AppButton, AppText, Screen, etc.)
  form/                # Form components (AppForm, AppFormField, etc.)
  layout/              # Layout components (TabBar, RequireAuth)
config/                # App configuration (colors, settings)
constants/             # Constants and icons
context/               # React contexts (AuthContext, UserContext, etc.)
hooks/                 # Custom hooks (useModal, useDebounce, etc.)
types/                 # TypeScript type definitions
utils/                 # Utility functions
data/                  # Mock data and validation schemas
lib/                   # API services and auth utilities
assets/                # Static assets (images, fonts)
```

## Naming Conventions

### Files
- **Components**: PascalCase (`ProfileCard.tsx`, `AppButton.tsx`)
- **Utilities**: camelCase (`validationUtils.ts`, `formatDate.ts`)
- **Types**: PascalCase with `.types.ts` suffix (`user.types.ts`, `dashboard.types.ts`)
- **Mock Data**: descriptive name with `.dummy.ts` suffix (`drawsData.dummy.ts`, `userData.dummy.ts`)
- **Validation Schemas**: descriptive with `Schema` suffix in `data/` folder (`validationSchema.ts`, `profileSchema.ts`)

### Components
- **UI components**: Prefixed with `App` (`AppButton`, `AppText`, `AppForm`, `AppInput`)
- **Feature components**: Descriptive names (eg: `ProfileCard`, `MatchCard`, `MessageBubble`)
- **Hooks**: Prefixed with `use` (`useModal`, `useDebounce`, `useAuth`, etc)
- **Contexts**: Suffixed with `Context` (`AuthContext`, `UserContext`)

### Variables
- **camelCase** for variables and functions
- **Boolean prefixes**: `is`, `has`, `can` (`isLoading`, `hasMatches`, `canMessage`)

### Imports
- **Organize imports** by separating third-party from local modules
- **Third-party first**: React, React Native, external libraries
- **Blank line separator**: Leave one blank line between third-party and local imports
- **Local imports**: Components, types, config, utils from `@/` paths
- **Example**:
```typescript
// Third-party imports
import React, { useState, useCallback } from 'react';
import { View, Text } from 'react-native';
import { FlashList } from '@shopify/flash-list';

// Local imports
import { AppButton, AppText } from '@/components/ui';
import { UserProfile } from '@/types/user.types';
import colors from '@/config/colors';
```

## Mock Data Pattern (Backend Not Ready)

Since the backend is not ready, simulate data based on documentation.

### Mock Images
- Use **Unsplash.com** for all mock profile photos and post images
- Format: `https://images.unsplash.com/photo-[id]?w=[width]&h=[height]&fit=crop`
- Use diverse, high-quality portraits for user profiles
- Use relevant lifestyle images for posts
- **NEVER** use local placeholder images (e.g., `require('@/assets/...')`) - use `blurhash` or Unsplash URLs instead

### Example 1: Get Current User Profile
**Documentation Data:**
```json
{
    "user_id": "usr_1234567890",
    "email": "user@example.com",
    "phone": "+1234567890",
    "first_name": "John",
    "last_name": "Doe",
    "country": "USA",
    "date_of_birth": "1990-01-15",
    "kyc_status": "verified",
    "kyc_verified_at": "2024-02-05T14:20:00Z",
    "email_verified": true,
    "phone_verified": true,
    "account_status": "active",
    "created_at": "2024-01-15T10:00:00Z",
    "updated_at": "2024-02-09T10:30:00Z",
    "referral_code": "JOHN1234",
    "referred_by": null
  }
```

**Implementation:**

1. **Create Type Definition** - `types/user.types.ts`:
```typescript
export interface CurrentUser {
  user_id: string;
  email: string;
  phone: string;
  first_name: string;
  last_name: string;
  country: string;
  date_of_birth: string; // ISO date string (e.g. "1990-01-15")
  kyc_status: "verified" | "pending" | "rejected" | string;
  kyc_verified_at: string | null; // ISO datetime string
  email_verified: boolean;
  phone_verified: boolean;
  account_status: "active" | "suspended" | "inactive" | string;
  created_at: string; // ISO datetime string
  updated_at: string; // ISO datetime string
  referral_code: string;
  referred_by: string | null;
}

```

2. **Create Mock Data** - `data/userData.dummy.ts`:
```typescript
import { CurrentUser } from "@/types/user.types";

export const currentUser: CurrentUser = {
    "user_id": "usr_1234567890",
    "email": "user@example.com",
    "phone": "+1234567890",
    "first_name": "John",
    "last_name": "Doe",
    "country": "USA",
    "date_of_birth": "1990-01-15",
    "kyc_status": "verified",
    "kyc_verified_at": "2024-02-05T14:20:00Z",
    "email_verified": true,
    "phone_verified": true,
    "account_status": "active",
    "created_at": "2024-01-15T10:00:00Z",
    "updated_at": "2024-02-09T10:30:00Z",
    "referral_code": "JOHN1234",
    "referred_by": null
  }
```

## Path Aliases
- `@/*` â†’ project root (e.g., `@/components`, `@/context`, `@/types`)

## Dark Mode Compatibility (CRITICAL)

**ALL components and screens MUST be dark mode compatible.** The app uses a dynamic theme system that switches between light and dark modes based on user preference.

### Core Principle
**NEVER hardcode colors directly in components.** Always use the `useColors` hook to access theme-aware colors.

### Using the useColors Hook

**Location**: `config/colors.ts`

**Import and Usage**:
```typescript
import { useColors } from '@/config/colors';

const MyComponent = () => {
  const colors = useColors();
  
  return (
    <View style={{ backgroundColor: colors.background }}>
      <Text style={{ color: colors.textPrimary }}>Hello</Text>
    </View>
  );
};
```

### Screen Component Wrapper (CRITICAL)

**ALL screens MUST be wrapped in the `Screen` component.**

**Location**: `components/ui/Screen.tsx`

The `Screen` component provides:
- âœ… **Theme-aware backgrounds** - Automatically uses correct background color for light/dark mode
- âœ… **Safe area handling** - Respects device notches, status bars, and navigation bars
- âœ… **Status bar configuration** - Auto-configures status bar style based on theme
- âœ… **Consistent padding** - Applies standard horizontal padding (`px-4`)

**Usage**:
```typescript
import Screen from '@/components/ui/Screen';

const MyScreen = () => {
  return (
    <Screen>
      {/* Your screen content here */}
      <View>
        <Text>Content automatically gets theme colors and safe area</Text>
      </View>
    </Screen>
  );
};
```

**With Custom Status Bar**:
```typescript
<Screen 
  statusBarStyle="light-content" 
  statusBarBg="#000000"
  className="px-0" // Override default padding if needed
>
  {/* Your content */}
</Screen>
```

**Why This Matters**:
- âŒ **Without Screen**: Manual theme handling, safe area issues, inconsistent status bars
- âœ… **With Screen**: Automatic theme support, safe areas handled, consistent UX

**Rule**: Every file in `app/` directory (screens/routes) MUST use the `Screen` wrapper as the root component.

### Keep Screen Files Minimal (CRITICAL)

**NEVER flood screen files with component code. Extract components into the `components/` folder.**

Screen files in the `app/` directory should be **minimal orchestration layers** that:
- Import and compose components
- Manage screen-level state and data fetching
- Handle navigation and routing logic
- Coordinate component interactions

**Bad Example** (Everything in screen file):
```typescript
// âŒ app/(tabs)/discover.tsx - TOO MUCH CODE
const DiscoverScreen = () => {
  return (
    <Screen>
      <View className="flex-row items-center justify-between px-4 py-3">
        <Text className="text-2xl font-bold">Discover</Text>
        <TouchableOpacity onPress={handleFilter}>
          <Icon name="filter" size={24} />
        </TouchableOpacity>
      </View>
      
      <View className="px-4 py-2">
        <TextInput placeholder="Search..." />
      </View>
      
      <FlashList
        data={profiles}
        renderItem={({ item }) => (
          <View className="bg-white rounded-lg p-4 mb-3">
            <Image source={{ uri: item.photo }} />
            <Text className="font-bold">{item.name}</Text>
            <Text>{item.bio}</Text>
            {/* 50+ more lines of card UI */}
          </View>
        )}
      />
    </Screen>
  );
};
```

**Good Example** (Components extracted):
```typescript
// âœ… app/(tabs)/discover.tsx - CLEAN AND MINIMAL
import { FlashList } from '@shopify/flash-list';
import { useState, useCallback } from 'react';

import {
  DiscoverHeader,
  DiscoverSearchBar,
  DiscoveryProfileCard,
  DiscoverFiltersModal,
  EmptyState,
} from '@/components/discover';
import Screen from '@/components/ui/Screen';
import { useColors } from '@/config';

const DiscoverScreen = () => {
  const colors = useColors();
  const [searchQuery, setSearchQuery] = useState('');
  const [showFilters, setShowFilters] = useState(false);
  const [profiles, setProfiles] = useState([]);

  const handleLike = useCallback((profileId: string) => {
    // Like logic
  }, []);

  return (
    <Screen>
      <DiscoverHeader 
        onFilterPress={() => setShowFilters(true)}
        onSearchPress={() => {/* ... */}}
      />
      
      <DiscoverSearchBar 
        value={searchQuery}
        onChangeText={setSearchQuery}
      />
      
      <FlashList
        data={profiles}
        renderItem={({ item }) => (
          <DiscoveryProfileCard 
            profile={item}
            onLike={handleLike}
          />
        )}
        ListEmptyComponent={<EmptyState type="no-profiles" />}
      />
      
      <DiscoverFiltersModal 
        visible={showFilters}
        onClose={() => setShowFilters(false)}
      />
    </Screen>
  );
};

export default DiscoverScreen;
```

**Component Organization**:

```
components/
  discover/                    # Feature-specific components
    DiscoverHeader.tsx         # Header with filter/search buttons
    DiscoverSearchBar.tsx      # Search input component
    DiscoveryProfileCard.tsx   # Profile card in list
    DiscoverFiltersModal.tsx   # Filters bottom sheet
    EmptyState.tsx             # Empty state component
    index.ts                   # Barrel export
  
  ui/                          # Reusable UI components
    Screen.tsx
    AppButton.tsx
    AppText.tsx
    ...
```

**Benefits**:
- âœ… **Readability**: Screen files are easy to understand at a glance
- âœ… **Reusability**: Components can be used across multiple screens
- âœ… **Testability**: Individual components are easier to test
- âœ… **Maintainability**: Changes to UI don't clutter screen logic
- âœ… **Collaboration**: Multiple developers can work on different components

**Rules**:
1. **Screen files should be < 200 lines** - If longer, extract components
2. **Create feature folders** - Group related components (e.g., `components/discover/`, `components/wallet/`)
3. **Use barrel exports** - Create `index.ts` in feature folders for clean imports
4. **One component per file** - Don't define multiple components in screen files
5. **Extract early** - Don't wait until the screen is messy, extract from the start

## Performance Optimization (CRITICAL)

Performance is a TOP PRIORITY for this application. Users expect fast, responsive experiences.

### List Rendering Strategy

**CRITICAL RULE**: Choose the right list component based on data size and characteristics.

#### Use FlashList (@shopify/flash-list) for:
- **Large datasets** (>20 items)
- **Dynamic/growing lists** (pagination, infinite scroll)
- **Performance-critical lists** (smooth scrolling required)

**FlashList Use Cases**:
1. **Draw History** - Potentially hundreds of past draws
2. **Transaction History** - Hundreds of transactions over time
3. **Notifications List** - Growing chronological list
4. **Success Stories** - Growing testimonial list
5. **Your Participation History** - All months participated

**FlashList Best Practices**:
```typescript
import { FlashList } from '@shopify/flash-list';

<FlashList
  data={items}
  renderItem={({ item }) => <ItemComponent item={item} />}
  estimatedItemSize={100} // REQUIRED: Provide accurate estimate
  keyExtractor={(item) => item.id}
  onEndReached={loadMore} // Pagination
  onEndReachedThreshold={0.5}
  ListEmptyComponent={<EmptyState />}
  ListFooterComponent={isLoading ? <LoadingSpinner /> : null}
/>
```

#### Use FlatList for:
- **Medium datasets** (10-20 items)
- **Static lists** that don't grow
- **Lists with complex interactions** (drag-drop, swipe actions)

**FlatList Use Cases**:
1. **Payment Methods** - Typically 1-3 items
2. **Recent Activity** - Last 5-10 items
3. **Quick Actions** - 4-6 items

#### Use ScrollView for:
- **Small datasets** (<10 items)
- **Static content** (How It Works, Settings)
- **Mixed content** (not uniform list items)

**ScrollView Use Cases**:
1. **Profile Settings** - 10-15 items
2. **How It Works Steps** - 3-4 items
3. **Onboarding Slides** - 3-4 slides
4. **Dashboard Quick Actions** - 4-6 items

### Component Optimization

**1. Memoization**:
```typescript
// Memoize expensive components
const ExpensiveComponent = React.memo(({ data }) => {
  return <View>{/* render */}</View>;
});

// Memoize callbacks
const handlePress = useCallback(() => {
  // handle press
}, [dependencies]);

// Memoize computed values
const computedValue = useMemo(() => {
  return expensiveCalculation(data);
}, [data]);
```

**2. Image Optimization**:
- Use `expo-image` instead of React Native Image
- Always provide `blurhash` for placeholders
- Compress images (max 500KB for profiles)
- Use appropriate sizes (don't load 4K images for thumbnails)
- Lazy load images in lists

```typescript
import { Image } from 'expo-image';

<Image
  source={{ uri: imageUrl }}
  placeholder={{ blurhash: 'L6PZfSi_.AyE_3t7t7R**0o#DgR4' }}
  contentFit="cover"
  transition={200}
  style={styles.image}
/>
```

**3. API Optimization**:
- Implement pagination (20-50 items per page)
- Cache frequently accessed data (AsyncStorage)
- Debounce search inputs (300ms minimum)
- Use optimistic updates for better UX
- Implement pull-to-refresh

```typescript
// Debounce example
const debouncedSearch = useDebounce(searchQuery, 300);

useEffect(() => {
  if (debouncedSearch) {
    searchAPI(debouncedSearch);
  }
}, [debouncedSearch]);
```

**4. Navigation Optimization**:
- Lazy load tab screens
- Preload critical screens
- Minimize navigation params
- Use native stack for better performance

### Loading States

**ALWAYS provide loading states**:
- Skeleton screens for initial loads
- Shimmer effects for content loading
- Spinners for actions
- Progress indicators for uploads

```typescript
// Skeleton example
{isLoading ? (
  <SkeletonLoader />
) : (
  <ActualContent data={data} />
)}
```

---

## Accessibility Requirements (CRITICAL)

**ALL screens and components MUST meet WCAG AA standards.**

### 1. Screen Reader Support

**Every interactive element MUST have accessible labels**:
```typescript
<TouchableOpacity
  accessibilityLabel="Make payment for this month"
  accessibilityHint="Opens payment screen"
  accessibilityRole="button"
>
  <Text>Pay Now</Text>
</TouchableOpacity>
```

**Accessibility Properties**:
- `accessibilityLabel`: Describes what the element is
- `accessibilityHint`: Describes what happens when activated
- `accessibilityRole`: Defines the element type (button, link, header, etc.)
- `accessibilityState`: Current state (selected, disabled, checked)

**Heading Hierarchy**:
```typescript
<Text accessibilityRole="header" accessibilityLevel={1}>
  Main Heading
</Text>
<Text accessibilityRole="header" accessibilityLevel={2}>
  Subheading
</Text>
```

### 2. Touch Targets

**Minimum touch target size: 44x44px**

```typescript
// Bad
<TouchableOpacity style={{ width: 20, height: 20 }}>
  <Icon name="close" size={16} />
</TouchableOpacity>

// Good
<TouchableOpacity style={{ width: 44, height: 44, justifyContent: 'center', alignItems: 'center' }}>
  <Icon name="close" size={16} />
</TouchableOpacity>
```

### 3. Color Contrast

**WCAG AA Requirements**:
- Normal text (16px+): 4.5:1 contrast ratio
- Large text (24px+): 3:1 contrast ratio
- UI components: 3:1 contrast ratio

**Test in both light and dark modes**

**Never rely solely on color**:
```typescript
// Bad - only color indicates error
<TextInput style={{ borderColor: 'red' }} />

// Good - color + icon + text
<View>
  <TextInput style={{ borderColor: colors.error }} />
  <Icon name="error" color={colors.error} />
  <Text style={{ color: colors.error }}>Invalid email</Text>
</View>
```

### 4. Form Accessibility

```typescript
<View>
  <Text accessibilityRole="text" nativeID="emailLabel">
    Email Address
  </Text>
  <TextInput
    accessibilityLabel="Email address"
    accessibilityLabelledBy="emailLabel"
    accessibilityHint="Enter your email to sign in"
    autoComplete="email"
    keyboardType="email-address"
    textContentType="emailAddress"
  />
  {error && (
    <Text
      accessibilityRole="alert"
      accessibilityLive="polite"
      style={{ color: colors.error }}
    >
      {error}
    </Text>
  )}
</View>
```

### 5. Dynamic Type Support

**Support text scaling (up to 200%)**:
```typescript
// Use relative sizes, not fixed
<Text style={{ fontSize: 16, lineHeight: 24 }}>
  Body text
</Text>

// Avoid fixed heights for text containers
<View style={{ minHeight: 44, paddingVertical: 8 }}>
  <Text>Flexible text container</Text>
</View>
```

### 6. Reduced Motion

**Respect user's motion preferences**:
```typescript
import { AccessibilityInfo } from 'react-native';

const [reduceMotion, setReduceMotion] = useState(false);

useEffect(() => {
  AccessibilityInfo.isReduceMotionEnabled().then(setReduceMotion);
}, []);

// Use in animations
<Animated.View
  style={{
    transform: [{
      translateX: reduceMotion ? 0 : animatedValue
    }]
  }}
/>
```

---

## Best Programming Practices

### 1. TypeScript Strict Mode

**ALWAYS use TypeScript with strict mode enabled**:
- Define interfaces for all data structures
- No `any` types (use `unknown` if necessary)
- Proper type guards for runtime checks
- Generic types for reusable components

```typescript
// Good
interface User {
  id: string;
  name: string;
  email: string;
}

const UserCard: React.FC<{ user: User }> = ({ user }) => {
  return <View>{/* render */}</View>;
};

// Bad
const UserCard = ({ user }: any) => {
  return <View>{/* render */}</View>;
};
```

### 2. Error Handling

**ALWAYS handle errors gracefully**:

```typescript
// API calls
try {
  const response = await api.makePayment(amount);
  // Success handling
} catch (error) {
  if (error.response?.status === 401) {
    // Handle authentication error
    logout();
  } else if (error.response?.status === 400) {
    // Handle validation error
    showError(error.response.data.message);
  } else {
    // Handle network/unknown error
    showError('Something went wrong. Please try again.');
  }
  // Log error for debugging
  console.error('Payment error:', error);
}
```

**Error Boundaries**:
```typescript
// Wrap critical sections with error boundaries
<ErrorBoundary fallback={<ErrorScreen />}>
  <CriticalComponent />
</ErrorBoundary>
```

### 3. Form Validation

**Use Formik + Yup for all forms**:

```typescript
import { Formik } from 'formik';
import * as Yup from 'yup';

const validationSchema = Yup.object().shape({
  email: Yup.string()
    .email('Invalid email')
    .required('Email is required'),
  password: Yup.string()
    .min(8, 'Password must be at least 8 characters')
    .required('Password is required'),
});

<Formik
  initialValues={{ email: '', password: '' }}
  validationSchema={validationSchema}
  onSubmit={handleSubmit}
>
  {({ handleChange, handleBlur, handleSubmit, values, errors, touched }) => (
    <View>
      <AppFormField
        name="email"
        placeholder="Email"
        error={touched.email && errors.email}
      />
      <AppButton onPress={handleSubmit} title="Submit" />
    </View>
  )}
</Formik>
```

### 4. Code Organization

**Keep components small and focused**:
- Single Responsibility Principle
- Extract complex logic to custom hooks
- Separate business logic from UI
- Maximum 200 lines per component (guideline)

```typescript
// Good - separated concerns
const usePaymentLogic = () => {
  const [isLoading, setIsLoading] = useState(false);
  
  const makePayment = async (amount: number) => {
    setIsLoading(true);
    try {
      const result = await api.payment(amount);
      return result;
    } finally {
      setIsLoading(false);
    }
  };
  
  return { makePayment, isLoading };
};

const PaymentScreen = () => {
  const { makePayment, isLoading } = usePaymentLogic();
  
  return <View>{/* UI only */}</View>;
};
```

### 5. Testing Requirements

**Write tests for critical functionality**:

**Unit Tests** (utils, helpers, validation):
```typescript
// validationUtils.test.ts
import { validateEmail } from './validationUtils';

describe('validateEmail', () => {
  it('should return true for valid email', () => {
    expect(validateEmail('test@example.com')).toBe(true);
  });
  
  it('should return false for invalid email', () => {
    expect(validateEmail('invalid')).toBe(false);
  });
});
```

**Component Tests** (critical UI components):
```typescript
import { render, fireEvent } from '@testing-library/react-native';
import { AppButton } from './AppButton';

describe('AppButton', () => {
  it('should call onPress when pressed', () => {
    const onPress = jest.fn();
    const { getByText } = render(
      <AppButton title="Click me" onPress={onPress} />
    );
    
    fireEvent.press(getByText('Click me'));
    expect(onPress).toHaveBeenCalled();
  });
});
```

### 6. Security Best Practices

**Sensitive Data Storage**:
```typescript
import * as SecureStore from 'expo-secure-store';

// Store tokens securely
await SecureStore.setItemAsync('authToken', token);

// Retrieve tokens
const token = await SecureStore.getItemAsync('authToken');

// Delete tokens
await SecureStore.deleteItemAsync('authToken');
```

**Never log sensitive data**:
```typescript
// Bad
console.log('User password:', password);
console.log('Auth token:', token);

// Good
console.log('Login attempt for user:', email);
console.log('Auth token received:', token ? 'Yes' : 'No');
```

### 7. Code Quality Tools

**Use ESLint and Prettier**:
- Configure ESLint for TypeScript
- Use Prettier for consistent formatting
- Run linting before commits
- Fix all warnings (zero-warning policy)

### 8. Documentation

**Document complex logic**:
```typescript
/**
 * Calculates the user's eligibility for the monthly draw
 * 
 * @param userId - The user's unique identifier
 * @param paymentStatus - Current month's payment status
 * @returns true if user is eligible, false otherwise
 * 
 * Eligibility criteria:
 * - Payment for current month must be completed
 * - Account must be active
 * - KYC must be verified
 */
const checkDrawEligibility = (
  userId: string,
  paymentStatus: PaymentStatus
): boolean => {
  // Implementation
};
```

---

## State Management Guidelines

### Context Usage

**Create contexts for global state**:
```typescript
// AuthContext.tsx
interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
}

export const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};
```

**Avoid prop drilling**:
- Use Context for data needed in many components
- Keep local state for component-specific data
- Use custom hooks to encapsulate context logic

---

## API Integration Guidelines

### API Client Setup

**Use Axios with interceptors**:
```typescript
// lib/apiClient.ts
import axios from 'axios';
import * as SecureStore from 'expo-secure-store';

const apiClient = axios.create({
  baseURL: process.env.EXPO_PUBLIC_API_URL,
  timeout: 10000,
});

// Request interceptor - add auth token
apiClient.interceptors.request.use(async (config) => {
  const token = await SecureStore.getItemAsync('authToken');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Response interceptor - handle errors
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      // Token expired - logout
      await SecureStore.deleteItemAsync('authToken');
      // Navigate to login
    }
    return Promise.reject(error);
  }
);

export default apiClient;
```

### API Service Pattern

```typescript
// lib/services/paymentService.ts
import apiClient from '../apiClient';

export const paymentService = {
  makePayment: async (amount: number) => {
    const response = await apiClient.post('/payments', { amount });
    return response.data;
  },
  
  getTransactionHistory: async (page: number = 1, limit: number = 20) => {
    const response = await apiClient.get('/payments/history', {
      params: { page, limit }
    });
    return response.data;
  },
};
```

---

## Offline Support

**Handle offline scenarios gracefully**:

```typescript
import NetInfo from '@react-native-community/netinfo';

const [isConnected, setIsConnected] = useState(true);

useEffect(() => {
  const unsubscribe = NetInfo.addEventListener(state => {
    setIsConnected(state.isConnected ?? false);
  });
  
  return () => unsubscribe();
}, []);

// Show offline banner
{!isConnected && (
  <View style={styles.offlineBanner}>
    <Text>No internet connection</Text>
  </View>
)}
```

---

## Performance Monitoring

**Track key metrics**:
- App startup time
- Screen transition time
- API response times
- Crash reports
- User analytics

**Use React Native Performance**:
```typescript
import { PerformanceObserver, performance } from 'react-native-performance';

// Mark important events
performance.mark('screen-loaded');

// Measure duration
performance.measure('screen-load-time', 'navigationStart', 'screen-loaded');
```

---

These guidelines ensure the app is performant, accessible, secure, and maintainable. Follow them strictly for all development work.